// create a structure of statements
// provide functions for generic queries
// how to do paging?

/* BASIC SQL COMMANDS:

insert
------
table
values
ex: INSERT INTO table (column, ...) VALUES (expression)

update
------
table
values
where
ex: UPDATE table SET (column) = (expression) WHERE (column) = (expression)

delete
-----
table
where
ex: DELETE FROM table WHERE (column) = (expression)

select
-----
what
where
ex: SELECT (columns) FROM table  WHERE (columns) = (expressions)

inner join
-----------
what
where
ex: SELECT (columns) FROM table INNER JOIN table ON (cols) = (cols) WHERE (cols) = (vals)

outer left join
-----------
what
where
ex: SELECT (columns) FROM table FULL JOIN table ON (cols) = (cols) WHERE (cols) = (vals)

outer right join
-----------
what
where
ex: SELECT (columns) FROM table FULL JOIN table ON (cols) = (cols) WHERE (cols) = (vals)


outer full join
-----------
what
where
ex: SELECT (columns) FROM table FULL JOIN table ON (cols) = (cols) WHERE (cols) = (vals)


queryrows
--------
rows.Next()
rows.Scan()

exec
-----
// Passes rows affected?

*/

// how to nick pagination
	// **** STUFF

// ** email list
	// make a new list
		INSERT INTO email_lists (name) VALUES ($1);
	// delete a list
		DELETE FROM email_lists WHERE (name) = ($1);
	// rename a list
		UPDATE email_lists SET (name) = ($1) WHERE (name) = ($2);
	// copy a list
		 // you're going to insert and select nest
		 // you're going to modify two tables
	// see lists
		SELECT * FROM email_lists;
	// fuzy search list by email
		SELECT * FROM email_lists_maps_users_or_emails WHERE (email_lists) = (SELECT id FROM email_lists WHERE (name) = ($2)) AND (email) % ($1);
	// exact search list by email
		SELECT * FROM email_lists_maps_users_or_emails WHERE (email, email_lists) = ($1, (SELECT id FROM email_lists WHERE (name) = ($2)));
	// fuzy search list by user
		SELECT node.user_id, node.nick, edge.email FROM emails_lists_maps_users_or_emails AS edge JOIN users AS node ON (edge.user_id) = (node.user_id) WHERE (edge.email_lists) = (SELECT id FROM email_lists WHERE (name) = ($1)) AND (node.nick) % ($2);
	// exact search list by user
		SELECT node.user_id, node.nick, edge.email FROM emails_lists_maps_users_or_emails AS edge JOIN users AS node ON (edge.user_id) = (node.user_id) WHERE (node.nick, edge.email_lists) = ($1, (SELECT id FROM email_lists WHERE (name) = ($2)));

	// get user:emails in list
		SELECT node.user_id, node.nick, edge.email FROM emails_lists_maps_users_or_emails AS edge LEFT JOIN users AS node ON edge.user_id = node.user_id WHERE (edge.email_lists) = (SELECT id FROM email_lists WHERE (name) =($1));
************************************************************************************* (you can subscribe with any email. if logged in, you are the default) **************
	// add email(s) to list
		INSERT INTO email_lists_maps_users_or_emails (email_lists, email) VALUES ($1, $2);
	// remove email(s) from list
		DELETE FROM email_lists_maps_users_or_emails WHERE (email_lists, email) VALUES ($1, $2);
	// add user to list
		INSERT INTO email_lists_maps_users_or_emails (email_lists, email, user_id) VALUES ($1, $2, $3);
	// remove user from list (email?)
		DELETE FROM email_lists_Maps_users_or_emails WHERE (user_id) VALUES ($1, $2, $3);
	// get lists e-mail is in
		SELECT email_lists FROM email_lists_maps_users_or_emails WHERE (email) = ($1)
	// get lists user is in
		SELECT email_lists FROM email_lists_maps_users_or_emails WHERE (user) = ($1)
	// associate email with user in email list
		UPDATE email_lists SET (user_id) = ($1) WHERE (email) = ($2);
	// deassociate email with user in email list
    WHAT

	// ** email stuff
	// add an email
		INSERT INTO  emails (email) VALUES ($1)
	// add an email with a user
		-- nickd by "create a user+password+nick+email"
	// add a userid to an e-mail
		-- nickd by "create a user+password+nick+email"
	// add an organization to an e-mail
		-- this is what organizations will see
	// delete user expiry
		DELETE FROM email_verification WHERE (expire >= now()); ----- TIMEZONE?
	// find all expired unverified users
	// switch an e-mail to primary
	// get a users emails
	// get a user email -- default or organization
	// get a user by email
	// remove an email

// ** user stuff
	// does user exist
		SELECT EXISTS (SELECT true FROM users WHERE nick = ($1))
	// create a user+password+nick+email
		BEGIN;

		SELECT EXISTS (SELECT true FROM emails WHERE email = ($1) AND user_id IS NULL);
		-- if no good, ROLLBACK
		WITH new_user_id AS ( INSERT INTO users (passhash, nick) VALUES (crypt($1, gen_salt('bf', 8)), $2) RETURNING user_id) INSERT INTO emails (email, user_id) VALUES ($3, (SELECT user_id FROM new_user_id) ) ON CONFLICT (email) DO UPDATE SET user_id = (SELECT user_id FROM new_user_id);
		-- if no good, ROLLBACK
		INSERT INTO email_verification (email) VALUES ($1) RETURN randomtoken; ---------- TIMEZONE?
		-- if no good, ROLLBACK

		END;
	// verify a password (login)
		SELECT nick FROM users WHERE (nick, passhash) = ($1, crypt($2, gen_salt('bf', 8)), 'nicknick')
	// change a users password
		UPDATE users SET password = crypt($1, gen_salt('bf', 8)) WHERE nick = $2 AND password = crypt($3, gen_salt('bf', 8))
	// change a users nick
		UPDATE users SET nick = $1 WHERE nick = $2 AND password = crypt($3, gen_salt('bf', 8))
	// delete a user
		DELETE FROM users WHERE nick = $1 AND password = crypt($3, gen_salt('bf', 8))

  // ** organization stuff
	// create an organization
	// delete an organization
	// change an orgs name

  // ** group stuff
	// create a group under an org
	// delete a group under an org
	// change an orgs name
	// add a user to a group with a certain permission
	// change a users permission in a group
	// remove a user from a group

	// PREPARE name (types,) AS statement - SELECT, INSERT, UPDATE, DELETE, VALUES
	// EXECUTE name (parameters,)


/* OLD DATABASE */
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS citext;
CREATE DOMAIN email_type AS citext
    CHECK ( VALUE ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );
		/* is it best to do this in the database... can we start with more conservative checks and then move onto more compelx checks? I mean i don't really know how this compiles */

/* Rationale behind separate Users and Accounts:
    Perhaps we want a separate login service separate from this specific (autopogo) service?
    Accounts hold login stuff, email/password. Users hold profile stuff, username/settings
*/

CREATE TABLE IF NOT EXISTS Accounts (
    email email_type NOT NULL PRIMARY KEY,
    passhash TEXT NOT NULL,
    user_id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE
);

/* type:
    BITS 0-1: unused
    BITS 2-3: admin,regular <-- def better in account, no?
        bit redundancy: assert(admin == ~regular) */
CREATE TABLE IF NOT EXISTS Users (
    user_id UUID NOT NULL REFERENCES Accounts(user_id) ON DELETE CASCADE PRIMARY KEY, /* yet here all users must have accounts... wouldnt it be user/account associations? */
    username VARCHAR(30) NOT NULL UNIQUE,
    firstname VARCHAR(30) NOT NULL DEFAULT '',
    lastname VARCHAR(30) NOT NULL DEFAULT '',
    type BIT(4) NOT NULL DEFAULT B'0001'
);

/* type:
    BITS 0-9: unused
    BITS 10-15: monitor,archived,pubread,pubwrite,demo,anon  <-- i think this is a bit backwards */
CREATE TABLE IF NOT EXISTS Projects (
    project_id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(100) NOT NULL DEFAULT '(New Project)',
    timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
    type BIT(16) NOT NULL DEFAULT B'0000000000000001',
    layer_count INT NOT NULL, /* i dont think this would normally be a table entry */
    pogo_count INT NOT NULL, /* same here */
    transform TEXT NULL DEFAULT NULL, /* hmm */
    data TEXT NULL DEFAULT NULL /* it needs to be an object */
);
CREATE INDEX projectsByTimestamp ON Projects USING btree ( timestamp ); 
CREATE INDEX projectsByType ON Projects USING btree ( type ); // <-- effectively clustering
/* wed definitely be searching by name as well? or no... maybe not */


/* access_flag:
    BITS 0-10: unused
    BITS 11-15: admread,admwrite,read,write,own */
CREATE TABLE IF NOT EXISTS Access (
    user_id UUID NOT NULL REFERENCES Users(user_id) ON DELETE CASCADE,
    project_id UUID NOT NULL REFERENCES Projects(project_id) ON DELETE CASCADE,
    access_flag BIT(16) NOT NULL,
    PRIMARY KEY(user_id,project_id)
);
CREATE INDEX accessByFlag ON Access USING btree ( access_flag );
CREATE INDEX projectsByUser ON Access USING btree ( user_id ); // this is kinda like your primary key
CREATE INDEX usersByProject ON Access USING btree ( project_id );

CREATE TABLE IF NOT EXISTS Monitors (
    monitor_id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    project_id UUID NOT NULL REFERENCES Projects(project_id) ON DELETE CASCADE, // I wonder what way cascade goes- OH THIS IS MONITORS
    data TEXT NULL DEFAULT NULL
);

/*
CREATE FUNCTION expire_old_projects() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM Projects WHERE Projects.type&B'0000000000000001' = B'0000000000000001' AND timestamp < NOW() - INTERVAL '1 day';
    DELETE FROM Projects WHERE Projects.type&B'0000000000000001' = B'0000000000000000' AND project_id NOT IN (SELECT project_id FROM access WHERE access_flag&B'0000000000000001' = B'0000000000000001');
    RETURN NEW;
END;
$$;

CREATE TRIGGER expire_old_projects_trigger
    BEFORE INSERT ON Projects
    EXECUTE PROCEDURE expire_old_projects();
*/
